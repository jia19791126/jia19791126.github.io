<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>unity寻路算法 | Sky小天的个人博客</title><meta name="author" content="sky小天"><meta name="copyright" content="sky小天"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="寻路算法A*寻路算法A*寻路就是用来计算玩家或者敌人的行进路径，通过它可以计算除避开阻挡的最短路径 基本原理开始寻找起点周围相邻的格子中所有不被阻挡的区域，找到后选择距离终点最近的点行走，之后再重复之前的操作，但不会寻找已经找过的点，直至到达终点。 详细原理寻路消耗公式：​		f(寻路消耗) &#x3D; g(离起点的距离) + h(离终点的距离，计算该距离最常用曼哈顿街区算法) 开启列表、关闭列">
<meta property="og:type" content="article">
<meta property="og:title" content="unity寻路算法">
<meta property="og:url" content="https://jia19791126.github.io/posts/15378.html">
<meta property="og:site_name" content="Sky小天的个人博客">
<meta property="og:description" content="寻路算法A*寻路算法A*寻路就是用来计算玩家或者敌人的行进路径，通过它可以计算除避开阻挡的最短路径 基本原理开始寻找起点周围相邻的格子中所有不被阻挡的区域，找到后选择距离终点最近的点行走，之后再重复之前的操作，但不会寻找已经找过的点，直至到达终点。 详细原理寻路消耗公式：​		f(寻路消耗) &#x3D; g(离起点的距离) + h(离终点的距离，计算该距离最常用曼哈顿街区算法) 开启列表、关闭列">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jia19791126.github.io/img/ava.jpg">
<meta property="article:published_time" content="2024-10-29T06:52:48.020Z">
<meta property="article:modified_time" content="2024-11-04T06:31:29.995Z">
<meta property="article:author" content="sky小天">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="algorithms">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Pathfinding Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jia19791126.github.io/img/ava.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jia19791126.github.io/posts/15378.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'unity寻路算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 14:31:29'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/friend_404.gif" data-original="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fa fa-folder-open"></i><span> 简历</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Sky小天的个人博客"><span class="site-name">Sky小天的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fa fa-folder-open"></i><span> 简历</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">unity寻路算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-29T06:52:48.020Z" title="发表于 2024-10-29 14:52:48">2024-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-04T06:31:29.995Z" title="更新于 2024-11-04 14:31:29">2024-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Pathfinding-Algorithms/">Pathfinding Algorithms</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="unity寻路算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h1><h2 id="A-寻路算法"><a href="#A-寻路算法" class="headerlink" title="A*寻路算法"></a>A*寻路算法</h2><p>A*寻路就是用来计算玩家或者敌人的行进路径，通过它可以计算除避开阻挡的最短路径</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>开始寻找起点周围相邻的格子中所有不被阻挡的区域，找到后选择距离终点最近的点行走，之后再重复之前的操作，但不会寻找已经找过的点，直至到达终点。</p>
<h3 id="详细原理"><a href="#详细原理" class="headerlink" title="详细原理"></a>详细原理</h3><h4 id="寻路消耗公式："><a href="#寻路消耗公式：" class="headerlink" title="寻路消耗公式："></a>寻路消耗公式：</h4><p>​		f(寻路消耗) &#x3D; g(离起点的距离) + h(离终点的距离，计算该距离最常用曼哈顿街区算法)</p>
<h4 id="开启列表、关闭列表及格子对象的父对象"><a href="#开启列表、关闭列表及格子对象的父对象" class="headerlink" title="开启列表、关闭列表及格子对象的父对象"></a>开启列表、关闭列表及格子对象的父对象</h4><p>​		开启列表和关闭列表相当于两个容器，开启列表中每一项包含该点，g(离起点的距离)，h(离终点的距离)和该点的父对象，关闭列表中每一项包含该点以及他的父对象。</p>
<p>​		父对象便是该格子对象的父对象</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/1.png"></p>
<p>​		从a点开始到达蓝色方块，先将a点放入关闭列表中，再去寻找周围8个点（从左到右，从上到下，依次为a1~a8），将可行走区域的点放入开启列表，并计算其g(离起点的距离)的值(计算两点之间的直线距离)，a2,a4,a5,a7为1加上父对象的g值，其余的为根号2约为1.4加上父对象的g值，使用曼哈顿街区算法计算出每个点的h(离终点的距离)值，由此可以得出每个点的f(寻路消耗)值，将找出的最优解的点移到关闭列表中。</p>
<p>​		之后从该点(可将其重命名)开始继续寻找周围的点，重复操作，选出最优值放入关闭列表中，每次选择最优解时要从开启列表中所有的点中选择（每次从新的点找周围的点时，如果周围的点已经再开启列表或者关闭列表中了，就不会再去管）。</p>
<p>​		每次关闭列表中放点时，应该判断这个点是不是终点，如果是证明路径已经找完，如果不是，则继续找。</p>
<p>​		经过操作到达终点后两个容器中内容如下(c点即b1点，b点即a5点，省略最后一步d点的相关计算)：</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/2.png"></p>
<h4 id="最终路径的确定"><a href="#最终路径的确定" class="headerlink" title="最终路径的确定"></a>最终路径的确定</h4><p>​		从选中的最后一个点开始，一层一层向上寻找父对象(两个列表中都存储的有),一直找到某个点没有父对象时，该点便为起点，而这条路径便为最终确认的路径。ps：不能直接选择关闭列表中所存储的点来确认路径。</p>
<p>​		以之前的放格图为例，假设终点左边一列除了最下面的格子其余全为阻挡，这时，到第三步时选择的则是c2点，之后在进行两次计算后，发现b2点位最优点，但这时c2点及之后一次计算的点已被放在关闭列表中，但很显然这两个点不是最终路径上要经过的点，所以这就是为什么不能直接选择关闭列表中的点当作最终路径的原因，这也是为什么每次计算不清空开启列表的原因。</p>
<h4 id="判断死路"><a href="#判断死路" class="headerlink" title="判断死路"></a>判断死路</h4><p>​		当遇到某个点周围没有未计算的可行走的区域时，便可判断起点到终点并没有可以到达的路径，便为死路。（此为粗略解释，详细细节会在之后代码处解释）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="/img/friend_404.gif" data-original="/../images/AI/3.png"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x;</span><br><span class="line">	<span class="type">float</span> y;</span><br><span class="line">	<span class="built_in">Vector2</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Vector2</span>(<span class="type">float</span> _x, <span class="type">float</span> _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AStarNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//坐标</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="comment">//寻路消耗</span></span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="comment">//离起点的距离</span></span><br><span class="line">	<span class="type">float</span> g;</span><br><span class="line">	<span class="comment">//离终点的距离</span></span><br><span class="line">	<span class="type">float</span> h;</span><br><span class="line">	<span class="comment">//格子类型(true为可行走区域，false为阻挡区域)</span></span><br><span class="line">	<span class="type">bool</span> isAllow;</span><br><span class="line">	<span class="comment">//父对象</span></span><br><span class="line">	AStarNode* father;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AStarNode</span>(<span class="type">float</span> _x, <span class="type">float</span> _y, <span class="type">bool</span> _isAllow) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y), <span class="built_in">isAllow</span>(_isAllow), <span class="built_in">f</span>(<span class="number">0</span>), <span class="built_in">g</span>(<span class="number">0</span>), <span class="built_in">h</span>(<span class="number">0</span>), <span class="built_in">father</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> AStarNode* a, <span class="type">const</span> AStarNode* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-&gt;f &gt; b-&gt;f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AStarMgr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//地图宽高</span></span><br><span class="line">	<span class="type">int</span> mapW;</span><br><span class="line">	<span class="type">int</span> mapH;</span><br><span class="line">	<span class="comment">//地图相关的格子对象容器</span></span><br><span class="line">	vector&lt;vector&lt;AStarNode*&gt;&gt; map;</span><br><span class="line">	<span class="comment">//开启列表</span></span><br><span class="line">	vector&lt;AStarNode*&gt; openList;</span><br><span class="line">	<span class="comment">//关闭列表</span></span><br><span class="line">	vector&lt;AStarNode*&gt; closeList;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> AStarMgr* instance;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AStarMgr</span>() : <span class="built_in">mapW</span>(<span class="number">0</span>), <span class="built_in">mapH</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AStarMgr</span>(<span class="type">const</span> AStarMgr&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝  </span></span><br><span class="line"></span><br><span class="line">	AStarMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AStarMgr&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁止赋值</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 判断点是否在开启列表或者关闭列表中</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isInOpenListOrCloseList</span><span class="params">(AStarNode*&amp; node)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> AStarNode* n : openList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (node == n)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> AStarNode* n : closeList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (node == n)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 把临近的点放入开启列表中</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FindNearLyNodeToOpenList</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">float</span> g, AStarNode*&amp; father, AStarNode*&amp; end)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//边界判断</span></span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= mapW ||</span><br><span class="line">			y &lt; <span class="number">0</span> || y &gt;= mapH)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//取点</span></span><br><span class="line">		AStarNode* node = map[y][x];</span><br><span class="line">		<span class="comment">//判断点是否时边界，是否时阻挡，是否再开启或者关闭列表中，如果不是，才放入开启列表</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span> ||</span><br><span class="line">			!node-&gt;isAllow ||</span><br><span class="line">			<span class="built_in">isInOpenListOrCloseList</span>(node))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//计算f值 f = g + h</span></span><br><span class="line">		<span class="comment">//记录父节点</span></span><br><span class="line">		node-&gt;father = father;</span><br><span class="line">		<span class="comment">//计算g</span></span><br><span class="line">		node-&gt;g = g + father-&gt;g;</span><br><span class="line">		node-&gt;h = <span class="built_in">abs</span>(end-&gt;x - node-&gt;x) + <span class="built_in">abs</span>(end-&gt;y - node-&gt;y);</span><br><span class="line">		node-&gt;f = node-&gt;g + node-&gt;h;</span><br><span class="line"></span><br><span class="line">		openList.<span class="built_in">push_back</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> AStarMgr* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">AStarMgr</span>();</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出地图</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;横向为x轴，纵向为y轴“.”为可行走区域，“*”为阻挡区域&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mapH; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; mapW; ++j) &#123;</span><br><span class="line">				cout &lt;&lt; (map[i][j]-&gt;isAllow ? <span class="string">&quot;.&quot;</span> : <span class="string">&quot;*&quot;</span>);</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 初始化地图</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;w&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;h&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">InitMap</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		mapW = w;</span><br><span class="line">		mapH = h;</span><br><span class="line"></span><br><span class="line">		map.<span class="built_in">resize</span>(h, <span class="built_in">vector</span>&lt;AStarNode*&gt;(w, <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建随机数引擎</span></span><br><span class="line">		default_random_engine e;</span><br><span class="line">		<span class="comment">//创建均匀分布</span></span><br><span class="line">		<span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">		<span class="comment">//使用当前时间为种子</span></span><br><span class="line">		e.<span class="built_in">seed</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; ++j) &#123;</span><br><span class="line">				AStarNode* node = <span class="keyword">new</span> <span class="built_in">AStarNode</span>(j, i, <span class="built_in">u</span>(e) &gt;= <span class="number">20</span>);</span><br><span class="line">				map[i][j] = node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">	<span class="comment">/// 寻找方法</span></span><br><span class="line">	<span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;startPos&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">	<span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line">	<span class="function">vector&lt;AStarNode*&gt; <span class="title">FindPath</span><span class="params">( Vector2 &amp;startPos, Vector2 &amp;endPos)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			在实际的项目应用中，传入进来的坐标并非严格按照方位置和个数来计算，</span></span><br><span class="line"><span class="comment">			需要进行一定的换算，将传入进来的坐标转换为咱们所需要的坐标方式</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断两点是否在地图范围内</span></span><br><span class="line">		<span class="keyword">if</span> (startPos.x &lt; <span class="number">0</span> || startPos.x &gt;= mapW ||</span><br><span class="line">			startPos.y &lt; <span class="number">0</span> || startPos.y &gt;= mapH ||</span><br><span class="line">			endPos.x &lt; <span class="number">0</span> || endPos.x &gt;= mapW ||</span><br><span class="line">			endPos.y &lt; <span class="number">0</span> || endPos.y &gt;= mapH) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入的两个点不在地图范围内&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//是否是阻挡区域</span></span><br><span class="line">		AStarNode* start = map[(<span class="type">int</span>)startPos.y][(<span class="type">int</span>)startPos.x];</span><br><span class="line">		AStarNode* end = map[(<span class="type">int</span>)endPos.y][(<span class="type">int</span>)endPos.x];</span><br><span class="line">		<span class="keyword">if</span> (!start-&gt;isAllow || !end-&gt;isAllow) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;开始或者结束点时阻挡区域&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		openList.<span class="built_in">clear</span>();</span><br><span class="line">		closeList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化起点的值，防止上一次寻路影响这次的寻路</span></span><br><span class="line">		start-&gt;father = <span class="literal">nullptr</span>;</span><br><span class="line">		start-&gt;f = <span class="number">0</span>;</span><br><span class="line">		start-&gt;g = <span class="number">0</span>;</span><br><span class="line">		start-&gt;h = <span class="number">0</span>;</span><br><span class="line">		closeList.<span class="built_in">push_back</span>(start);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//定义比较器</span></span><br><span class="line">		<span class="keyword">auto</span> myCompare = [](AStarNode* a, AStarNode* b) &#123;</span><br><span class="line">			<span class="keyword">return</span> a-&gt;f &lt; b-&gt;f;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//开始寻路</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">//从起点开始找周围的点并放入开启列表中</span></span><br><span class="line">			<span class="comment">//左上</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x - <span class="number">1</span>, start-&gt;y - <span class="number">1</span>, <span class="number">1.4f</span>, start, end);</span><br><span class="line">			<span class="comment">//上</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x, start-&gt;y - <span class="number">1</span>, <span class="number">1.0f</span>, start, end);</span><br><span class="line">			<span class="comment">//右上</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x + <span class="number">1</span>, start-&gt;y - <span class="number">1</span>, <span class="number">1.4f</span>, start, end);</span><br><span class="line">			<span class="comment">//左</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x - <span class="number">1</span>, start-&gt;y, <span class="number">1.0f</span>, start, end);</span><br><span class="line">			<span class="comment">//右</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x + <span class="number">1</span>, start-&gt;y, <span class="number">1.0f</span>, start, end);</span><br><span class="line">			<span class="comment">//左下</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x - <span class="number">1</span>, start-&gt;y + <span class="number">1</span>, <span class="number">1.4f</span>, start, end);</span><br><span class="line">			<span class="comment">//下</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x, start-&gt;y + <span class="number">1</span>, <span class="number">1.0f</span>, start, end);</span><br><span class="line">			<span class="comment">//右下</span></span><br><span class="line">			<span class="built_in">FindNearLyNodeToOpenList</span>(start-&gt;x + <span class="number">1</span>, start-&gt;y + <span class="number">1</span>, <span class="number">1.4f</span>, start, end);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//死路判断</span></span><br><span class="line">			<span class="keyword">if</span> (openList.<span class="built_in">empty</span>())&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;死路，无法到达终点&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//选出开启列表中寻路消耗最小的点</span></span><br><span class="line">			<span class="built_in">stable_sort</span>(openList.<span class="built_in">begin</span>(), openList.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//放入关闭列表中，让那后再从开启列表中移除</span></span><br><span class="line">			closeList.<span class="built_in">push_back</span>(openList.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">			start = openList.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">			openList.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断当前的点是否时终点</span></span><br><span class="line">			<span class="keyword">if</span> (start == end)</span><br><span class="line">			&#123;</span><br><span class="line">				vector&lt;AStarNode*&gt; path;</span><br><span class="line">				path.<span class="built_in">push_back</span>(end);</span><br><span class="line">				<span class="keyword">while</span> (end-&gt;father != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					path.<span class="built_in">push_back</span>(end-&gt;father);</span><br><span class="line">					end = end-&gt;father;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> path;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">AStarMgr* AStarMgr::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AStarMgr* mgr = AStarMgr::<span class="built_in">GetInstance</span>();</span><br><span class="line">	<span class="type">int</span> w, h, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入需要构建的地图大小（第一个整数时宽，第二个整数为高）：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; w &gt;&gt; h;</span><br><span class="line">	mgr-&gt;<span class="built_in">InitMap</span>(w, h);</span><br><span class="line">	mgr-&gt;<span class="built_in">printMap</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入起点坐标&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="function">Vector2 <span class="title">startPos</span><span class="params">(x, y)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输入终点坐标&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	<span class="function">Vector2 <span class="title">endPos</span><span class="params">(x, y)</span></span>;</span><br><span class="line">	vector&lt;AStarNode*&gt; path = mgr-&gt;<span class="built_in">FindPath</span>(startPos, endPos);</span><br><span class="line">	<span class="keyword">if</span> (!path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;最终路径为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; path[i]-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; path[i]-&gt;y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死路判断，当openlist为空，即找不到未走过的路时便可得出无法到达终点。</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="障碍邻点的预计算。"><a href="#障碍邻点的预计算。" class="headerlink" title="障碍邻点的预计算。"></a>障碍邻点的预计算。</h4><p>​		判断周围格子是否有障碍还有计算格子的cost价值，如果在每次寻路的时候才去算就太浪费了，因为每次寻路的时候每个格子相邻的障碍是不会变的，价值cost也不变，我们大可以把这块计算抽出放到初始地图的时候计算。步骤如下:</p>
<p>​		1.给节点添加邻节点数组nodeLinks，和邻节点价值组costLinks。(也可建一个linkNode对象，对象里面有节点和价值两属性，反正两数组是个映对关系),保证nodeLinks[i]的价值是costLinks[i]</p>
<p>​		2.地图初始好的时候遍历每个格子，计算出其周围的所有非障碍的格子，并加入节点邻数组中存起。计算每个邻节点的价值，映对存入节点价值组。</p>
<p>​		3.寻路的时候判断节点四周有哪些格子直接从当前计算的节点的nodeLinks属性取即可，不需要再计算。</p>
<p>预计算可节省很多性能，不过缺点是初始的时候很慢。 </p>
<h4 id="Array数组优化"><a href="#Array数组优化" class="headerlink" title="Array数组优化"></a>Array数组优化</h4><p>​		Array的indexOf和shift方法是很吃性能的，很多人的A星在while里面有这两个东西，这是那几百毫秒慢下的原因。怀疑的同学可以自己写个1万次的大循环调用这两个方法看看。要判断节点是否在开户组里面，普通人的做法是用indexOf，其实这个方式可以换成以下处理</p>
<p>1.给节点添加isOpen:Boolean属性</p>
<p>2.每次push节点到打开数组的里面设节点的isOpen为true</p>
<p>3.节点移出打开列表时，将节点的isOpen属性设为false</p>
<p>4.判断节点是否在开启列表时只需要判断isOpen即可</p>
<p>判断关闭同理，另外还有会用上indexOf的地方是二叉堆里面，干掉方式略。</p>
<p>​		将关闭组添加到通过父节点添加到返回路径时，很多人会用shift，把节点一个个添到path数组里面，这也是个慢的因素。可以换成push方式，push不会改变索引，所以效率很高。将关闭节点组数据通过push加入路径后，再调用reverse把数组倒置，结果跟用shift一样，不过用时可大不一样。</p>
<h4 id="打开关闭标记，换掉不用重置"><a href="#打开关闭标记，换掉不用重置" class="headerlink" title="打开关闭标记，换掉不用重置"></a>打开关闭标记，换掉不用重置</h4><p>​		用isOpen来替代indexOf大大提升了一步性能，可是每次寻路完之后会有个问题，那就是要把节点重置，就是把所有打开和关闭列表里面的节点的isOpen,isClose设false。呵呵，虽然这个重置吃的性能相当小，不过本着追求精神，我又找出了更变态的方式。步骤如下</p>
<p>1.每次A星计算设一唯一自增标记markIndex,每计算一次寻路，这个整型属性+1</p>
<p>2.把节点里面的isOpen和isClose布尔属性改成openMark,closeMark整型属性。</p>
<p>3.加入列表时把openmark设为本次计算的自动标记markIndex，移出列表设为-1（或随便一个不等于markIndex的数)</p>
<p>4.判断是否在打开列表中只需判断if(openMark&#x3D;&#x3D;markIndex)即可</p>
<p>5.某次寻路计算完之后markIndex+1</p>
<p>​		因为自增标记每次计算都不一样，所以节点的openMark不需要重置，下次也能继续用。这个方式带来的性能提升很微小不多，不追求那几十毫秒的大可无视。</p>
<h4 id="减少while里面get-set-function"><a href="#减少while里面get-set-function" class="headerlink" title="减少while里面get&#x2F;set&#x2F;function"></a>减少while里面get&#x2F;set&#x2F;function</h4><p>​		get&#x2F;set的性能其实很高，不过在项目中，大量的格子一经过while方法就是数万次的运算，虽然每次性能相差很少，但量一大起来效率就明显了。不信的人可以写个大循环在里面用getter和public属性的方式对比一下，性能相差三四倍。如果节点的f,g,h,x,y这些属性用了接口get&#x2F;set，那个运算毫秒相差就很明显了。function 是代码设计不可省的东西，这一步优化只适合在A星的while中用，正常项目中可省不得。</p>
<h4 id="位运算，再提一提微小的性能"><a href="#位运算，再提一提微小的性能" class="headerlink" title="位运算，再提一提微小的性能"></a>位运算，再提一提微小的性能</h4><p>​		在二叉堆中的除以2，num&#x2F;2&#x3D;&#x3D;num<em>0.5&#x3D;&#x3D;num &gt;&gt; 1，这三个种计算方式最快的明显是第三种，虽然可读性差些，不过效率还是有点提升滴。另外num</em>2 &#x3D;&#x3D; num&lt;&lt;1;也可提升些性能</p>
<p>优化前5条原文章：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/pelephone/archive/2012/09/27/2704902.html">http://www.cnblogs.com/pelephone/archive/2012/09/27/2704902.html</a></p>
<h4 id="使用二叉堆"><a href="#使用二叉堆" class="headerlink" title="使用二叉堆"></a>使用二叉堆</h4><p>​	在寻路过程中，因为每次都要从开启列表中取出消耗最小的点来进行下一步操作，一般情况下为了方便快速取到需要的点，所以每次都会进行排序，在每次放入新点时，都会与列表中的各个点的消耗值进行比较，一变把其放在合适的位置，但是随着地图增大，每次插入新的点时，所消耗的时间会随着增长，所以为此而引入二叉堆，即将开启列表中的元素以堆的形式存放，根节点方消耗最小的点。</p>
<p>​		使用二叉堆存放时，一般可以使用以为数组进行储存(节点从下标为1开始而非从0开始)，只需要节点上移和下移操作保证每个节点的f值大于等于两个子节点的f值，小于等于其父节点的f值就可以了，并不需要保证这个一维数组严格排序，这时每次进行插入操作时所需要的比较次数就会减少，而且其与正常存储之间的差距会随着实际地图大小（地图节点的多少）的增大，而随几何倍的增长，但是若是时间地图很小，那么使用二叉堆和不适用二叉堆的差距就不会很大，所以一般地图不是很大的时候，并不会去使用二叉堆去优化。</p>
<h5 id="向堆中添加元素"><a href="#向堆中添加元素" class="headerlink" title="向堆中添加元素"></a>向堆中添加元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addPointReszie</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> last = openList.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(last &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> half = last &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(openList[last].f &gt;= openList[half].f)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        AStarNode* temp = openList[Last];</span><br><span class="line">        openList[last] = openList[half];</span><br><span class="line">        openList[half] = temp;</span><br><span class="line">        last &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从队中删除元素"><a href="#从队中删除元素" class="headerlink" title="从队中删除元素"></a>从队中删除元素</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removePointResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> last = openList.size - <span class="number">1</span>;</span><br><span class="line">    openList[<span class="number">1</span>] = openList[last];</span><br><span class="line">    openlist.<span class="built_in">pop_back</span>();</span><br><span class="line">    last = openList.size - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((head &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= last)&#123;</span><br><span class="line">        <span class="type">int</span> child1 = head &lt;&lt; <span class="number">1</span>, child2 = child1 + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> childMin = openList[child1].f &lt; openList[child2].f ? child1 : child2;</span><br><span class="line">        <span class="keyword">if</span>(openList[head].f &lt;= openList[childMin].f)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        AStarNode* temp = openList[head];</span><br><span class="line">        openList[head] = openList[childMin];</span><br><span class="line">        openList[childMin] = temp;</span><br><span class="line">        head = childMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对开启列表的元素重排"><a href="#对开启列表的元素重排" class="headerlink" title="对开启列表的元素重排"></a>对开启列表的元素重排</h5><p>参数i为所需要重排的元素所在数组下标位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reSetPointResize</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> last = i;</span><br><span class="line">    <span class="keyword">while</span>(last &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> half = last &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(openList[last].f &gt;= openList[half].f)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        AStarNode* temp = openList[Last];</span><br><span class="line">        openList[last] = openList[half];</span><br><span class="line">        openList[half] = temp;</span><br><span class="line">        last &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NavMesh导航系统"><a href="#NavMesh导航系统" class="headerlink" title="NavMesh导航系统"></a>NavMesh导航系统</h2><p>Recast Navigation源码分析：(<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/484520809">https://zhuanlan.zhihu.com/p/484520809</a>)</p>
<p>​		NavMesh所依据的库是Recast Navigation，NavMesh来进行计算，生成寻路所需要的信息，最后由DetailMesh执行寻路操作。</p>
<p>运行基本逻辑图</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/4.png"></p>
<p>​		NavMesh是根据碰撞器来进行输入，由游戏引擎将场景里的碰撞器集聚成一个Mesh，输出给Recast，而Recast是将以三角形集合形式表示的空间场景转化为可供使用的导航数据(navmesh)，detour部分是根据recast生成的navmesh，为指定源点和终点生成直线段路径。</p>
<h3 id="Meadow-mapping"><a href="#Meadow-mapping" class="headerlink" title="Meadow mapping"></a>Meadow mapping</h3><p>​		在看Recast Navigation前，可以先了解一下最早的凸多边形化算法Meadow mapping，最早是由Ronald C. Arkin 在1986提出，提出了使用凸多边形构建可行走区域。并使用A*在其中寻路。从可行走区域，挖去遮挡物所占区域，输出由凸多边形组成的2D Footprint。</p>
<h4 id="整体需要实现的操作"><a href="#整体需要实现的操作" class="headerlink" title="整体需要实现的操作"></a>整体需要实现的操作</h4><p><img src="/img/friend_404.gif" data-original="/../images/AI/7.png"></p>
<p>根据以上Roadmap，实现对应gongneng。</p>
<h4 id="如何划分凸多边形区域"><a href="#如何划分凸多边形区域" class="headerlink" title="如何划分凸多边形区域"></a>如何划分凸多边形区域</h4><p><img src="/img/friend_404.gif" data-original="/../images/AI/5.png"></p>
<p>​		如果一个区域已经是凸多边形，则直接结束算法，若不是，则选择多边形内部一个角度大于180度的点，尝试和多变内部另一个点连接起来，把这个角给干掉，此时得到两个新的区域，然后不断重复进行这个操作，直至多少有多边形凸多边形化。</p>
<h5 id="如何判断是否为凸多边形"><a href="#如何判断是否为凸多边形" class="headerlink" title="如何判断是否为凸多边形"></a>如何判断是否为凸多边形</h5><p>​		检查多边形内部是否由大于180度的角，没有便是凸多边形，此时问题便变为如何判断角度大于180度。</p>
<p>​		假设，我们所要计算的凸多边形给的这个节点的书讯是以你是正的顺序给的</p>
<img src="/img/friend_404.gif" data-original="../images/AI/6.png" style="zoom:100%;" />

<p>​		例如图右边的例子，若x+在向量x-x的右边时，则x这个角大于180度，若是在左边则这个角度小于180度。</p>
<p>​		判断是否在左边可以使用叉乘计算判断：右手定则。如果叉乘结果是正的，它就是在左边，为负就是在右边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">left</span><span class="params">(Vector2&amp; x, Vector2&amp; y, Vector2&amp; z)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Vecto2是一个结构体，里面包含x,y两个float类型，代表坐标</span></span><br><span class="line">    <span class="comment">//为了简便向量也用Vector2表示</span></span><br><span class="line">    <span class="function">Vector2 <span class="title">xy</span><span class="params">((y.x - x.x), (y.y - x.y))</span></span>;</span><br><span class="line">    <span class="function">Vector2 <span class="title">yz</span><span class="params">((z.x - y.x), (z.y - x.y))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (xy.x * yz.y - xy.y * yz.y) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		遍历多边形所有节点，如果有concave节点(角度大于180度)就返回其坐标，否则就返回-1(为convex)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindConcaveVertex</span><span class="params">(vector&lt;Vector2*&gt; &amp;verts, vector&lt;<span class="type">int</span>&gt; &amp;indices)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = indices.<span class="built_in">size</span>()</span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> iaPrev = (i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> iaNext = (i + <span class="number">1</span> &lt; n) ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">leftOn</span>(verts[indices[iaPrev]], verts[indices[i], verts[indices[iaNext]]))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>verts用于存储多边形的各个点，indices用于存储多边形点在verts里的位置，即索引</p>
<h4 id="将返回的顶点与多边形中其它“可见”的顶点相连"><a href="#将返回的顶点与多边形中其它“可见”的顶点相连" class="headerlink" title="将返回的顶点与多边形中其它“可见”的顶点相连"></a>将返回的顶点与多边形中其它“可见”的顶点相连</h4><img src="/img/friend_404.gif" data-original="../images/AI/8.png" style="zoom:60%;" />

<p>​		以此图中a点为例，其中ac，ad，ae这三条线在多边形内部，所以c，d，e为“可见”的顶点，因为ag在多边形外面，af跨越了多边形，所以g，f点不是“可见”顶点。只有当这条线不和非相邻的边交叉并且在多边形内部才是符合条件的。</p>
<h5 id="检测不和非临边相交"><a href="#检测不和非临边相交" class="headerlink" title="检测不和非临边相交"></a>检测不和非临边相交</h5><p>​		可以继续使用点在线段哪侧来判断，若两条线段ab,cd其中a点和b点分别在cd线段两侧，而且c点和d点同时也分别在ab线段两侧，此时可以说这两条线段是相交的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(Vector2 &amp;a, Vector2 &amp;b, Vector2 &amp;c, Vector2 &amp;d)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> cdCross = ((<span class="built_in">left</span>(a, b, c) &amp;&amp; !<span class="built_in">left</span>(a, b, d)) ||</span><br><span class="line">                    (!<span class="built_in">left</span>(a, b, c) &amp;&amp; <span class="built_in">left</span>(a, b, d)));</span><br><span class="line"> 	<span class="type">bool</span> abCross = ((<span class="built_in">left</span>(c, d, a) &amp;&amp; !<span class="built_in">left</span>(c, d, b)) ||</span><br><span class="line">					(!<span class="built_in">left</span>(c, d, a) &amp;&amp; <span class="built_in">left</span>(c, d, b)));</span><br><span class="line">    <span class="keyword">return</span> (cdCross &amp;&amp; abCross);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		改进：如果出现共线情况下的解决方法</p>
<p>​		假设a，b，c共线，那么当且仅当c在a，b当中时，为共线。</p>
<p>改进后代码在判断是否点是否在线段两侧前，向判断其中三点是否共线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(Vector2 &amp;a, Vector2 &amp;b, Vector2 &amp;c, Vector2 &amp;d)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">collinear</span>(a, b, c))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">between</span>(a, b, c);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">collinear</span>(a, b, d))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">between</span>(a, b, d);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">collinear</span>(c, d, a))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">between</span>(c, d, a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">collinear</span>(c, d, b))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">between</span>(c, d, b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> cdCross = ((<span class="built_in">left</span>(a, b, c) &amp;&amp; !<span class="built_in">left</span>(a, b, d)) ||</span><br><span class="line">                    (!<span class="built_in">left</span>(a, b, c) &amp;&amp; <span class="built_in">left</span>(a, b, d)));</span><br><span class="line"> 	<span class="type">bool</span> abCross = ((<span class="built_in">left</span>(c, d, a) &amp;&amp; !<span class="built_in">left</span>(c, d, b)) ||</span><br><span class="line">					(!<span class="built_in">left</span>(c, d, a) &amp;&amp; <span class="built_in">left</span>(c, d, b)));</span><br><span class="line">    <span class="keyword">return</span> (cdCross &amp;&amp; abCross);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		其中collinear用于判断三点是否共线，可以用向量cb和ba的叉乘是否很小接近0来判断三点是否共线，between可以直接使用左边来进行计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">diagonalie</span><span class="params">(vector&lt;Vector2*&gt; &amp;verts, vector&lt;<span class="type">int</span>&gt; &amp;indices, <span class="type">int</span> ia, <span class="type">int</span> ib)</span></span>&#123;</span><br><span class="line">    n = indices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>: i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indices[i] == indices[ia] <span class="keyword">or</span> indices[i] == indices[ib])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> nextI = (i + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">if</span>(indices[nextI] = indices[ia] <span class="keyword">or</span> indices[nextI] == indices[ib])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">intersect</span>(verts[indices[ia]], verts[indices[ib]], verts[indices[i]], verts[indices[nextI]]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		以上代码为判断多边形中的两点连成的线段是否与其非相邻线段相交。</p>
<h5 id="检测线段是否在多边形内部"><a href="#检测线段是否在多边形内部" class="headerlink" title="检测线段是否在多边形内部"></a>检测线段是否在多边形内部</h5><p>​		可以将其转换为检测对角线是否在多边形内部</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/9.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inCone</span><span class="params">(vector&lt;Vector2*&gt; &amp;verts, vector&lt;<span class="type">int</span>&gt; &amp;indices, <span class="type">int</span> ia, <span class="type">int</span> ib)</span></span>&#123;</span><br><span class="line">    n = indices.<span class="built_in">size</span>();</span><br><span class="line">    iaPrev = (ia - <span class="number">1</span> &gt;= <span class="number">0</span>) ? ia - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line">    iaNext = (ia + <span class="number">1</span> &gt;= <span class="number">0</span>) ? ia + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ia = indices[id];</span><br><span class="line">    ib = indices[ib];</span><br><span class="line">    iaPrev = indices[iaPrev];</span><br><span class="line">    iaNext = indices[iaNext];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">leftOn</span>(verts[iaPrev], verts[ia], verts[iaNext]))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">left</span>(verts[ia], verts[ib], verts[iaPrev]) &amp;&amp;</span><br><span class="line">               <span class="built_in">left</span>(verts[ib], verts[ia], verts[iaNext]));</span><br><span class="line">    <span class="keyword">return</span> !(<span class="built_in">leftOn</span>(verts[ia], verts[ib], verts[iaNext]) &amp;&amp;</span><br><span class="line">            <span class="built_in">leftOn</span>(verts[ib], verts[ia], verts[iaPrev]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>diagonal的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">diagonal</span><span class="params">(vector&lt;Vector2*&gt; &amp;verts, vector&lt;<span class="type">int</span>&gt; &amp;indices, <span class="type">int</span> ia, <span class="type">int</span> ib)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">inCone</span>(verts, indices, ia, ib) &amp;&amp; </span><br><span class="line">           <span class="built_in">inCone</span>(verts, indices, ib, ia) &amp;&amp;</span><br><span class="line">           <span class="built_in">diagonalie</span>(verts, indices, ia, ib));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/friend_404.gif" data-original="/../images/AI/10.png"></p>
<p>​		在开销方面因为diagonalie中判断与非临边是否相交需要遍历多边形多有的边，所以</p>
<p>一般会选择a和b中选择，这样若是该边不在多边形内部就不用去计算相交问题，虽然此处代码写的是a的类型，但在Recast Navigation中并不需要堆再进行第二个的inCone的计算。</p>
<p>​		最后convexify的实现就是再使用二分法来实现</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：可以站立的区域，阻挡物位置</span><br><span class="line">初始化：将阻挡物和边界合并，放入行走区域中</span><br><span class="line"></span><br><span class="line">如果 区域是凸(convex)的</span><br><span class="line">    结束</span><br><span class="line">不然 找到一个凹(concave, &gt;180)的角，将其连接到可见顶点。对新的两块区域继续递归调用当前算法。</span><br></pre></td></tr></table></figure>

<h4 id="合并洞"><a href="#合并洞" class="headerlink" title="合并洞"></a>合并洞</h4><p>​		当处理带hole的多边形时，可将hole上一点连接到多边形上一个可见的点，即可将空洞并入到多边形上，如下图所示：</p>
<img src="/img/friend_404.gif" data-original="../images/AI/11.png" style="zoom:50%;" />

<p>​		进行缝合之后，便可以得到一个简单的多边形，之后便可进行convexify操作。</p>
<p>​		在Recast Navigation中，rcBuildPolyMesh使用的时耳切法(Ear Clipping)的算法去处理，死路与之相似。</p>
<p>​		耳切法使用更加聪明的方式，时每个切出来的区域都是单独的三角形，避免了Meadow Mapping递归调用的额外开销，不过在之后recast会将这些三角形重新组装成凸多边形，避免有太多的三角形导致之后寻路的开销过大。</p>
<h3 id="体素化"><a href="#体素化" class="headerlink" title="体素化"></a>体素化</h3><h4 id="为什么要体素化"><a href="#为什么要体素化" class="headerlink" title="为什么要体素化"></a>为什么要体素化</h4><p>​		在很多的材料中，体素化皆在处理Polygon Soup(多边形大乱炖)问题。在面对若干Mesh时，体素化能够将多个Mesh同一成一种表达。体素化一般在Recast Navigation Build的过程中占据耗时量的80%~90%，所以怎么去优化体素化是一个关键问题。</p>
<p>​		体素化对于一些有场景破坏的场景有着更好的性能，而且在Navmesh构建过程中体素化也是一个非常重要的步骤。</p>
<h4 id="体素化的实现"><a href="#体素化的实现" class="headerlink" title="体素化的实现"></a>体素化的实现</h4><p>​		切割三角面，算法思路</p>
<p>​		1）遍历所有碰撞每个三角面</p>
<p>​		2）沿水平面垂直(y轴)切分（以Cell Size切分）</p>
<p>​		3）沿水平面水平(x轴)切分（以Cell Size切分）</p>
<p>​		4）将切分下来的多边形体素化（水品面切分后能保证在一个Cell里，这时根据多边形z值最大最小值，覆盖所有经过的Voxel）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void dividePoly(</span><br><span class="line">	const float* in, int nin, 输入多边形和节点个数</span><br><span class="line">	float* out1, int* nout1, 输出多边形1和节点个数</span><br><span class="line">	float* out2, int* nout2, 输出多边形2和节点个数</span><br><span class="line">	float x, int axis</span><br><span class="line">)	x为切的具体坐标</span><br><span class="line">	axis为在第几个维度（x轴为0，y轴为1，z轴为2）去切分多边形</span><br></pre></td></tr></table></figure>

<p>​		dividePoly核心思路：逆时针遍历节点</p>
<p>​		1）根据节点在axis左右决定加入哪个多边形</p>
<p>​		2）根据之前节点在axis左右，决定是否要添加新增节点（由于edge被线切分导致）</p>
<p>以下图为例来说明</p>
<img src="/img/friend_404.gif" data-original="../images/AI/12.png" style="zoom:75%;" />

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line">1）发现xi处在切分线左边，加入out1多边形</span><br><span class="line">2）发现xi-1处在切分先右边，xi和xi-1不在同侧。往两个多边形都插入新增节点（根据切分线位置插值）。</span><br></pre></td></tr></table></figure>

<img src="/img/friend_404.gif" data-original="../images/AI/13.png" style="zoom:75%;" />

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第二步</span><br><span class="line">1）发现xi处在切分先左边，加入out1多边形</span><br><span class="line">2）发现xi-1处在切分先右边，xi和xi-1在同侧，此时，什么都不做。</span><br></pre></td></tr></table></figure>

<p>​		之后依次循环遍历每个节点，根据节点所在分割线位置，来将点分在不同的子多边形。</p>
<img src="/img/friend_404.gif" data-original="../images/AI/14.png" style="zoom:75%;" />

<p>​		遍历完成之后，便可将原来的多边形分为以上图片所示的两个小多边形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">dividePoly</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* in, <span class="type">int</span> nin, </span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="type">float</span>* out1, <span class="type">int</span>* nout1, </span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="type">float</span>* out2, <span class="type">int</span>* nout2, </span></span></span><br><span class="line"><span class="params"><span class="function">						<span class="type">float</span> x, <span class="type">int</span> axis)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> d[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nin; ++i)</span><br><span class="line">        d[i] = x - in[i * <span class="number">3</span> + axis];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = nin - <span class="number">1</span>; i &lt; nin; j = i, ++i)&#123;</span><br><span class="line">        <span class="type">bool</span> ina = d[j] &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> inb = d[i] &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ina != inb)&#123;</span><br><span class="line">            <span class="type">float</span> s = d[j] / (d[j] - d[i]);</span><br><span class="line">            out1[m*<span class="number">3</span><span class="number">+0</span>] = in[j*<span class="number">3</span><span class="number">+0</span>] + (in[i*<span class="number">3</span><span class="number">+0</span>] - in[j*<span class="number">3</span><span class="number">+0</span>])*s;</span><br><span class="line">            out1[m*<span class="number">3</span><span class="number">+1</span>] = in[j*<span class="number">3</span><span class="number">+1</span>] + (in[i*<span class="number">3</span><span class="number">+1</span>] - in[j*<span class="number">3</span><span class="number">+1</span>])*s;</span><br><span class="line">            out1[m*<span class="number">3</span><span class="number">+2</span>] = in[j*<span class="number">3</span><span class="number">+2</span>] + (in[i*<span class="number">3</span><span class="number">+2</span>] - in[j*<span class="number">3</span><span class="number">+2</span>])*s;</span><br><span class="line">        	<span class="comment">//将分割线与线段相交的点依次添加到两个凸多边形out1和out2中</span></span><br><span class="line">            <span class="built_in">rcVcopy</span>(out2 + n*<span class="number">3</span>, out1 + m*<span class="number">3</span>);</span><br><span class="line">            ++m;</span><br><span class="line">            ++n;</span><br><span class="line">            <span class="comment">//判断端点i在分割线的下边或者左边，则将i放入out1中，否则加入out2中</span></span><br><span class="line">            <span class="keyword">if</span>(d[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            	<span class="built_in">rcVcopy</span>(out1 + m*<span class="number">3</span>, in + i*<span class="number">3</span>);</span><br><span class="line">                ++m;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">rcVcopy</span>(out2 + m*<span class="number">3</span>, in + i*<span class="number">3</span>);</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">rcVcopy</span>(out1 + m*<span class="number">3</span>, in + i*<span class="number">3</span>);</span><br><span class="line">                ++m;</span><br><span class="line">                <span class="comment">//若点是在分割线的下边或者左边，则不需要往多边形out2中添加</span></span><br><span class="line">                <span class="keyword">if</span>(d[i] != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rcVcopy</span>(out2 + n*<span class="number">3</span>, in + i*<span class="number">3</span>);</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *nout1 = m;</span><br><span class="line">    *nout2 = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		由dividePoly切分出来的多边形水平上处在一个Cell当中，我们可以确定水平上(x,y)的坐标，将其树枝上z轴接触的区域全部标记为“占有”。例如下图：</p>
<img src="/img/friend_404.gif" data-original="../images/AI/15.png" style="zoom:60%;" />

<p>​		该多边形接触到了三个体素（可以根据z轴的值去判断），所以将这三个体素去不标记为“占有”。</p>
<p>​		为什么说不使用跟简单的光栅化流水线+插值的方式，因为在使用该方法时会导致体素不连续，这对于台阶等这类斜面的徐璐是致命的。</p>
<h4 id="体素化的表达"><a href="#体素化的表达" class="headerlink" title="体素化的表达"></a>体素化的表达</h4><p>Recast Idea：使用Run-Length encoding压缩体素空间</p>
<p>下面是一个Column下的表达（实际的体素化空间由水品面上2D列阵的Column表示）</p>
<img src="/img/friend_404.gif" data-original="../images/AI/16.png" style="zoom:75%;" />

<p>三种存储各有优劣：</p>
<p>​		DenseArray的表达方式虽然消耗的内存较大，但是我们在场景中新增一个体素或者碰撞体的时候，只需要花费O(1)的时间就可完成，而且对于要之多一个爬墙的多做来说，也会跟容易的找到那些是可行走的区域。</p>
<p>​		SolidHeightField的表达（以链表的形式）会对与一大片连接在一起的被“占用”的体素进行一个合并存储，这样对于内存的消耗会有一个很大的节省，在对于一个动态建筑（包含建造玩法），去将新的体素化时标胶好做（相对于第三种存储的方式）。但是当遇到需要查询时，则会消耗比DenseArray存储的查询更多的时间（根据坐标去查询是否被占有，需要遍历整个链表）。</p>
<p>​		CompactHeightField的表达，因为存储的为可以走区域，所以对于查询可行走区域时有着很好优势，但是对于增删改确实很难进行。</p>
<h3 id="Recast-Navigation"><a href="#Recast-Navigation" class="headerlink" title="Recast Navigation"></a>Recast Navigation</h3><p>​		Recast Navigation分为recast和detour两个部分，由recast输出导航数据，由detour接受经处理生成可供寻路的路径。</p>
<h4 id="recast"><a href="#recast" class="headerlink" title="recast"></a>recast</h4><h5 id="recast的输入"><a href="#recast的输入" class="headerlink" title="recast的输入"></a>recast的输入</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cellSize————x、z方向上的体素精度</span><br><span class="line"></span><br><span class="line">walkableSlopeAngle————agent的可行走最大坡度</span><br><span class="line"></span><br><span class="line">walkableHeight————agent的可行走的最小高度</span><br><span class="line"></span><br><span class="line">walkableClimb————agent的可攀爬高度</span><br><span class="line"></span><br><span class="line">walkableRadius————agent的行走半径</span><br><span class="line"></span><br><span class="line">float* bmin和float* bmax————场景的AABB包围盒</span><br><span class="line"></span><br><span class="line">int* tris数组————场景的三角形序列</span><br><span class="line"></span><br><span class="line">ntris————场景的三角形个数</span><br><span class="line"></span><br><span class="line">float* verts————场景三角形各个顶点的坐标</span><br><span class="line"></span><br><span class="line">nverts————场景三角形的顶点总数</span><br></pre></td></tr></table></figure>

<p>​		若一个场景由3个三角形和5个顶点组成，则5个顶点的坐标由float* verts[3 * nverts]存储，分别表示nverts(5)个顶的x，y，z坐标，3个三角形则由float* tris[3 * ntris]存储，分别表示ntris(3)个三角形的3*ntris个顶点在verts数组中的下标。在这个例子中verts数组中的内容是[x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,x5,y5,z5]，而tris[3 * ntris]数组的内容是[0,1,2,1,2,4,2,3,4]。</p>
<h5 id="标记可行走的三角形"><a href="#标记可行走的三角形" class="headerlink" title="标记可行走的三角形"></a>标记可行走的三角形</h5><img src="/img/friend_404.gif" data-original="../images/AI/17.png" style="zoom:75%;" />

<p>​		如上图，三角形的坡度较为Φ，我们利用向量V2V1和向量V2V3的叉乘得到三角形的法向量，对法向量归一化成单位法向量，那么此时单位向量的Y轴坐标便是坡度较的余弦值，法向量的Y坐标大于最大可行走坡度较的余弦值时说明该三角形时可行走的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rcMarkWalkableTriangles</span><span class="params">(rcContext* ctx, <span class="type">const</span> <span class="type">float</span> walkableSlopeAnle,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> <span class="type">float</span>* verts, <span class="type">int</span> nv,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> <span class="type">int</span>* tris, <span class="type">int</span> nt,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">unsigned</span> <span class="type">char</span>* areas)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rcIgnoreUnised</span>(ctx);</span><br><span class="line">    <span class="built_in">rcIgnoreUnused</span>(nv);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> walkableThr = <span class="built_in">cosf</span>(waklableSlopAngle/<span class="number">180.0f</span> * RC_PI);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> norm[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nt; ++i)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span>* tri = &amp;tris[i*<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">calcTrNormal</span>(&amp;verts[tri[<span class="number">0</span>]*<span class="number">3</span>], &amp;verts[tri[<span class="number">1</span>]*<span class="number">3</span>], &amp;verts[tri[<span class="number">2</span>]*<span class="number">3</span>], norm);</span><br><span class="line">        <span class="keyword">if</span>(norm[<span class="number">1</span>] &gt; walkableThr)</span><br><span class="line">            areas[i] = RC_WALKABLE_AREA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构建高度场HeightField"><a href="#构建高度场HeightField" class="headerlink" title="构建高度场HeightField"></a>构建高度场HeightField</h5><p>​		该表达方式已在前面介绍锅，此处不在介绍。</p>
<p>​		高度场对象结构体和实心柱结构体即体素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实心高度场对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rcHeightField</span>&#123;</span><br><span class="line">    <span class="built_in">rcHeightFileld</span>();</span><br><span class="line">    ~<span class="built_in">rcHeightFileld</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> width; <span class="comment">//高度场的宽度（沿x轴，以单元为单位）</span></span><br><span class="line">    <span class="type">int</span> height; <span class="comment">//高度场的高度（沿z轴，以单元为单位）</span></span><br><span class="line">    <span class="type">float</span> bmin[<span class="number">3</span>]; <span class="comment">//世界空间中的最小边界。[(x, y, z)]</span></span><br><span class="line">    <span class="type">float</span> bmax[<span class="number">3</span>]; <span class="comment">//世界空间中的最大边界。[(x, y, z)]</span></span><br><span class="line">    <span class="type">float</span> cs; <span class="comment">//每个单元格的大小。（在xz平面）</span></span><br><span class="line">    <span class="type">float</span> ch; <span class="comment">//每个单元格的高度。（沿y轴的最小增量）</span></span><br><span class="line">    rcSpan** spans; <span class="comment">//实心柱的链表结构（大小时width*height）</span></span><br><span class="line">    rcSpanPool* pools; <span class="comment">//链表的对象池</span></span><br><span class="line">    rcSpan* freelist; <span class="comment">//下一个free span</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//禁止外部调用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">rcHeightField</span>(<span class="type">const</span> rcHightField&amp;);</span><br><span class="line">    rcHeightField&amp; <span class="keyword">operator</span>=(<span class="type">const</span> rcHeightField&amp;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实心柱对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rcSpan</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> smin : RC_SPAN_HEIGHT_BITS; <span class="comment">//span的下限。[Limit: &lt; #smax]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> smax : RC_SPAN_HEIGHT_BITS; <span class="comment">//span的上限。[Limit : &lt;= #RC_SPAN_MAX_HEIGHT]</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> area : <span class="number">6</span>; <span class="comment">// 当前三角面的可行走标记</span></span><br><span class="line">    rcSpan* next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		对于一个体素插入到链表数组里的哪个链表中，是由x + z * width的值来决定的，这个值代表所插入链表在数组中的下标。比如x&#x3D;1，z&#x3D;1出体素就查到下标为3的链表中。如果待插入体素的y坐标范围与链表中已有体素的y坐标范围由重合，则需要做体素合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高度场构建的核心代码</span></span><br><span class="line"><span class="comment">//hf为当前高度场，cur为当前span，s为新的spans</span></span><br><span class="line"><span class="comment">//插入并合并spans</span></span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;smin &gt; s-&gt;smax)&#123;</span><br><span class="line">        <span class="comment">// 当前的span比新的span更远</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;smax &lt; s-&gt;smin)&#123;</span><br><span class="line">        <span class="comment">//当前的span在新的span的之前</span></span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//合并spans</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;smin &lt; s-&gt;smin)</span><br><span class="line">            s-&gt;min = cur-&gt;smin;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;smax &gt; s-&gt;smax)</span><br><span class="line">            s-&gt;smax = cur-&gt;smax;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">rcABs</span>((<span class="type">int</span>)s-&gt;smax - (<span class="type">int</span>)cur-&gt;smax) &lt;= flagMergeThr)</span><br><span class="line">            s-&gt;area = <span class="built_in">rcMax</span>(s-&gt;area, cur-&gt;area);</span><br><span class="line">        </span><br><span class="line">        rcSpan* next = cur-&gt;next;</span><br><span class="line">        <span class="built_in">freeSpan</span>(hf, cur);</span><br><span class="line">        <span class="keyword">if</span>(prev)</span><br><span class="line">            prev-&gt;next = next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hf.spans[idx] = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的spans</span></span><br><span class="line"><span class="keyword">if</span>(prev)&#123;</span><br><span class="line">    s-&gt;next = prev-&gt;next;</span><br><span class="line">    prev-&gt;next = s;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    s-&gt;next = hf.spans[idx];</span><br><span class="line">    hf.spans[idx] = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="高度场的可行走标记修正"><a href="#高度场的可行走标记修正" class="headerlink" title="高度场的可行走标记修正"></a>高度场的可行走标记修正</h5><p>定义：</p>
<p>walkableHeight ———— actor行走所需要的最小垂直高度。</p>
<p>walkableClimb ———— actor所能攀爬的最大垂直高度。</p>
<p>第一种情况，如下图：</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/18.png"></p>
<p>如果体素A是可行走的，并且height &lt; walkahleClimb，则体素B也是可行走的。</p>
<p>第二种情况，如下图：</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/19.png"></p>
<p>定义邻居体素可达的条件为：min(top, ntop) - max(bot, nbot) &gt; walkableHeight。则对于某个体素，其所有可达的邻居体素中：</p>
<p>1.如果存在(bot - nbot &gt; walkableClimb)，则将该体素修正为不可行走。</p>
<p>2.如果max(nbot) - min(nbot) &gt; walkableClimb，则将该体素修正为不可行走。</p>
<p>第三种情况：当两个上下排列的体素之间的间隔height &lt; walkableHeight， 则体素A需要修正为不可走。</p>
<h5 id="构建紧凑高度场CompactHeightfield-反体素化"><a href="#构建紧凑高度场CompactHeightfield-反体素化" class="headerlink" title="构建紧凑高度场CompactHeightfield(反体素化)"></a>构建紧凑高度场CompactHeightfield(反体素化)</h5><p>遍历之前的高度场数据，将体素信息转为反体素，反体素的y&#x3D;体素的上沿y坐标，反体素的h&#x3D;(链表下一个体素的下沿y坐标或者最大y坐标-该体素的上沿y坐标)，不可行走的体素不用转换为反体素，</p>
<p>某个地点(x、z坐标)处的；体素被访问时，首先计算值(x + z * width)，用这个值去元信息数组中访问rcCompactCell数据。元信息数据中的index代表该处位置的反体素在反体素数组中的开始下标，count字段表示该地点(x、z坐标)有几层反体素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rcCompactCell</span>&#123;</span><br><span class="line">  	<span class="type">unsigned</span> <span class="type">int</span> index : <span class="number">24</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>计算反体素的连通性：修正那一小段的第二种情况的图为例，若这两个反体素想要联通，需要满足两个条件。</p>
<p>1.2个反体素的y坐标差值要小于等于agent的攀爬高度，即(bot - nbot) &lt;&#x3D; walkahleClimb。</p>
<p>2.2个反体素的重叠部分的h要大于等于可行走高度，即(ntop - bot) &gt;&#x3D; walkableHeight。</p>
<p>某个反体素与前后左右4个邻居反体素的连通信息存储在反体素结构的con字段，每个方向占6个bit，相应bit值表征连通邻居反体素的layer层。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rcCompactSpan</span>&#123;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> y;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> reg;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> con : <span class="number">24</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h : <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如con字段的二进制值为000001 000010 000000 000100时，意义如下：</p>
<ol>
<li><p>左方向，该体素与layer为1的体素连通</p>
</li>
<li><p>上方向，该体素与layer为2的体素连通</p>
</li>
<li><p>右方向，该体素无连通体素</p>
</li>
<li><p>下方向，该体素与layer为4的体素连通</p>
</li>
</ol>
<h5 id="裁剪可行走区域"><a href="#裁剪可行走区域" class="headerlink" title="裁剪可行走区域"></a>裁剪可行走区域</h5><p>我们采用dist数组来保存每个反素体与可行走区域边缘的最近距离。</p>
<img src="/img/friend_404.gif" data-original="../images/AI/20.png" style="zoom:75%;" />

<p>对于上图的中间那个体素：</p>
<p>1.从左到右、由下及上扫描反体素时，绿色的那4个邻居体素已先被扫描到。</p>
<p>2.从右到左、由上及下扫描反体素时，蓝色的那4个邻居体素已先被扫描到。</p>
<p>因此，我们可以通过上述两次对所有反体素的扫描可以得到每个反体素与可行走区域边缘的最近距离。</p>
<p>对于dist值小于agent直径的反体素，将其标记为不可行走。</p>
<h5 id="标记体素掩码值"><a href="#标记体素掩码值" class="headerlink" title="标记体素掩码值"></a>标记体素掩码值</h5><p>​		通过部署一些多边形柱子，然后遍历所有反体素，对于在多边形柱子内的反体素，将其areaId标记为相应值。areaId表示该体素是否可行走，是否是山地、草地之类。</p>
<p>​		后续的区域划分会确保1个区域不会包含两种areaId，detour寻路也支持对于不同的areaId定义不同的单位路径损耗cost。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ConvexVolume* vols = m_geom-&gt;<span class="built_in">getConvexVolumes</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_geom-&gt;<span class="built_in">getConvexVolumeCount</span>(); ++i)</span><br><span class="line">    <span class="built_in">rcMarkConvexPolyArea</span>(m_ctx, vols[i], vols[i].nverts, vols[i].hmin, vols[i].hmax, (unsigened <span class="type">char</span>)vols[i].area, *m_vhf);</span><br></pre></td></tr></table></figure>

<h5 id="区域划分算法"><a href="#区域划分算法" class="headerlink" title="区域划分算法"></a>区域划分算法</h5><p>1）分水岭(watershed)：racast默认算法，效果好，速度慢。</p>
<p>2）Monotone：速度快，但是生成的Region可能会又细又长，效果一般。</p>
<p>3）layers：类同monotone，只是区域在生成过程中不会有叠层(不会跨相同x、z坐标的多个y坐标体素)。</p>
<p>分水岭算法</p>
<p>​		首先也是构建距离场dist数组(反体素到边界的距离)，这个过程与前面裁剪可行走区域过程中构建距离场非常类似。区别仅在于对非边界体素的判定：前者是前后左右4个方向都存在连通邻居并且体素掩码相同；后者只需要前后左右4个方向都存在连通邻居。</p>
<p>​		距离场构建完后，需要再对dist数组进行均值降噪处理。体素到边界的距离修正为 (自身到边界距离 + 8个邻居到边界距离) &#x2F;9，如果有邻居不连通，则用自身到边界的距离补位。</p>
<img src="/img/friend_404.gif" data-original="../images/AI/21.png" style="zoom:100%;" />

<p>1.首先根据前面构建的距离场将体素划分到不同的批次，每隔2个距离场1个批次(看代码发现如果dist数组的最大值d是偶数，则第一个批次会包含d-2、d-1、d 三个距离的体素)。</p>
<p>2.从距离场最大的批次开始填充水位，新水位填充后立刻进行深度优先泛洪邻居体素。</p>
<p>3.新批次的体素，进行广度优先泛洪邻居体素，尚未被泛洪到的体素进行新水位填充。</p>
<p>如上图所示，最终体素被划分成了A、B、C三个区域。</p>
<ul>
<li>Monotone算法</li>
</ul>
<p>​		称某一行的连续体素成为一个sweepSpan，该算法从左到右逐行扫描体素，每扫描完一行体素，针对该行体素形成的一系列sweepSpan进行判断：如果某个sweepSpan A在-y方向上的邻居sweepSpan只有1个并且该邻居在+y方向上的邻居也只有1个(必然是sweepSpan A)，那么合并这两个sweepSpan。</p>
<img src="/img/friend_404.gif" data-original="../images/AI/22.png" style="zoom:100%;" />

<h5 id="区域裁剪"><a href="#区域裁剪" class="headerlink" title="区域裁剪"></a>区域裁剪</h5><p>做区域裁剪前，需要找出每个区域的邻接区域。寻找邻接区域的流程如下图所示：</p>
<img src="/img/friend_404.gif" data-original="../images/AI/23.png" style="zoom:85%;" />

<p>比如下面这个图中：</p>
<p>1.区域7的邻接区域为区域6、3、8、9、5</p>
<p>2.区域5的邻接区域为区域4、6、7、9</p>
<img src="/img/friend_404.gif" data-original="../images/AI/24.png" style="zoom:85%;" />

<p>找出邻接区域后，再做如下处理来完成区域裁剪。</p>
<p>1.针对每个区域，采用深度优先遍历其所有邻接区域，如果最终包含的体素数目小于minRegionArea，则将遍历到的所有区域裁剪掉。我理解这个操作是为了减少比较小的孤立区域。</p>
<p>2.对体素数量过少的区域A进行合并，合并到最小的邻接区域B中。合并过程中，需要将A的邻接区域合并到B的邻接区域中，针对所有区域的邻接区域，需要将其中的A区域需要替换为B区域。</p>
<p>3.经过区域裁剪和合并后，region会变少，需要对区域的regionID重新remap赋值，以此来降低regionID的最大值。</p>
<h5 id="生成轮廓线"><a href="#生成轮廓线" class="headerlink" title="生成轮廓线"></a>生成轮廓线</h5><p>与寻找邻接区域类似，都是沿着区域边界顺时针行走。行走过程中取轮廓点的规则为:</p>
<ol>
<li><p>体素左方是边界，轮廓点取其上方体素。</p>
</li>
<li><p>体素上方是边界，轮廓点取其右上方体素。</p>
</li>
<li><p>体素右方是边界，轮廓点取其右方体素。</p>
</li>
<li><p>体素下方是边界，轮廓点取其自身。</p>
</li>
</ol>
<p>这样做的目的是，使得各个区域的轮廓线多边形的边互相重合。最终效果如下图所示：</p>
<img src="/img/friend_404.gif" data-original="../images/AI/25.png" style="zoom:90%;" />

<p>轮廓线简化：简化的目的是使用尽可能少的直线段来逼近带毛刺的边界。整个简化过程如下：</p>
<ol>
<li><p>左下角和右上角顶点作为初始轮廓。</p>
</li>
<li><p>对于轮廓线段，遍历线段中间的其它顶点，找到偏离线段最远的顶点，如果偏离距离大于指定值，则将该顶点加入轮廓。</p>
</li>
<li><p>一直迭代，直到所有顶点与轮廓的距离在指定值内。</p>
</li>
</ol>
<p>检查轮廓线的空洞</p>
<p>​	如果顶点的存储顺序为V1,V2,V3,V4,V5.如果按存储顺序去点的话们应该是V1V2、V2V3、V3V4、V4V5和V5V1.但Recast源码计算多边形面积，确是与此相反。因此空洞轮廓线的顶点存储虽然是逆时针，但其面积反而为负数。下图是计算多边形面积的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">calcAreaOfPolygon2D</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* verts, <span class="type">const</span> <span class="type">int</span> nverts)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取顶点顺序与顶点的存储顺序刚好相反</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = nverts - <span class="number">1</span>; ji &lt; nverts; j = i++)&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span>* vi = &amp;verts[i*<span class="number">4</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span>* vj = &amp;verts[j*<span class="number">4</span>];</span><br><span class="line">        area +=vi[<span class="number">0</span>] * vj[<span class="number">2</span>] - vj[<span class="number">0</span>] * vi[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (area + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是利用多边形面积检测空洞的相关代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nholes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cset.nconts; ++i)&#123;</span><br><span class="line">    rcContour&amp; cont = cset.conts[i];</span><br><span class="line">    </span><br><span class="line">    winding[i] = <span class="built_in">calcAreaOfPolygon2D</span>(cont.verts, vont.nverts) &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(winding[i] &lt; <span class="number">0</span>)</span><br><span class="line">        ++nboles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并空洞</p>
<p>分为四步：</p>
<p>1）找到空洞的左下方顶点B4</p>
<p>2）将轮廓线所有顶点与B4相连，如果连线与轮廓线、空洞都不相交，则连线构成1条对角线。</p>
<p>3）选择其中长度最短的1条对角线，将空洞合并到轮廓线中。</p>
<p>如果包含多个空洞的话，将空洞按左下方顶点排序，依次迭代将外围轮廓与空洞进行合并。</p>
<p>轮廓线的三角剖分(耳切法)</p>
<p>定义：<br>1）顶点是一个凸点</p>
<p>2）左右顶点相连的对角线与其它边不相交</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/26.png"></p>
<p>在上图，V1、V4、V4、V6是耳尖</p>
<p>将对角线最短的耳尖V1进行切割，切割后需要对左右相邻的顶点是否为耳尖重新判断，</p>
<p>切割后耳尖为V2、V4、V5、V6、V7。经过多次迭代后，行程多个三角形。</p>
<h5 id="凸多边形的合并"><a href="#凸多边形的合并" class="headerlink" title="凸多边形的合并"></a>凸多边形的合并</h5><p>轮廓线经过三角剖分后形成了一系列凸多边形(三角形是最简单的凸多边形)。为了提升detour寻路的效率，我们需要凸多边形进行合并。</p>
<p>2个凸多边形必须满足下面两个条件才可以合并：</p>
<p>1）必须要有公共边</p>
<p>2）合并后，公共边的2个顶点是否能维持凸多边形。</p>
<h4 id="detour寻路"><a href="#detour寻路" class="headerlink" title="detour寻路"></a>detour寻路</h4><p>​		通过前面的体素化、构建高度场、区域划分、轮廓线生成、三角剖分、凸多边形合并，我们将场景构建成了一系列可用于寻路的凸多边形。</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/27.png"></p>
<p>Detour寻路算法步骤分为：<br>1）寻找离起点A和终点B距离最近的凸多边形</p>
<p>2）通过A*寻路算法找出点A到点B所经过的凸多边形序列</p>
<p>3）通过漏斗算法确认出最终路径</p>
<h5 id="如何寻找最近的凸多边形"><a href="#如何寻找最近的凸多边形" class="headerlink" title="如何寻找最近的凸多边形"></a>如何寻找最近的凸多边形</h5><p>​		为了提升查找效率，我们利用所有凸多边形构建一颗BVH树，查找时，将点扩张为小正方体，判断是否相交或者是否是叶子节点，如果是，则对于相交的叶子节点，取出其中的凸多边形。继续迭代下一个节点。如果为否，则为不相交的非叶子节点，通过继续遍历索引找到右子树。</p>
<p>这颗BVH树的特点有：<br>1）根节点的包围盒包含左右子树的包围盒。</p>
<p>2）叶子节点才存储凸多边形数据。</p>
<p>3）划分左右子树的时候，选择最能均匀分割多边形的坐标轴。</p>
<p>构建BVH树的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">subdivide</span><span class="params">(BVItem* items, <span class="type">int</span> nitems, <span class="type">int</span> imin, <span class="type">int</span> imax, 					<span class="type">int</span>&amp; curNode, dtBVNode* nodes)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> inum = imax - imin;</span><br><span class="line">    <span class="type">int</span> icur = curNode;</span><br><span class="line">    </span><br><span class="line">    dtBVNode&amp; node = nodes[curNode++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(inum == <span class="number">1</span>)&#123;</span><br><span class="line">        node.bmin[<span class="number">0</span>] = items[imin].bmin[<span class="number">0</span>];</span><br><span class="line">        node.bmin[<span class="number">1</span>] = items[imin].bmin[<span class="number">1</span>];</span><br><span class="line">        node.bmin[<span class="number">2</span>] = items[imin].bmin[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        node.bmax[<span class="number">0</span>] = items[imin].bmax[<span class="number">0</span>];</span><br><span class="line">        node.bmax[<span class="number">0</span>] = items[imin].bmax[<span class="number">0</span>];</span><br><span class="line">        node.bmax[<span class="number">0</span>] = items[imin].bmax[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        node.i = items[imin].i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">calcExtends</span>(items, nitems, imin, imax, node.bmin. node.bmax);</span><br><span class="line">        <span class="type">int</span> axis = <span class="built_in">longestAxis</span>(node.bmax[<span class="number">0</span>] - node.bmin[<span class="number">0</span>],</span><br><span class="line">        					  node.bmax[<span class="number">1</span>] - node.bmin[<span class="number">0</span>],</span><br><span class="line">                              node.bmax[<span class="number">2</span>] - node.bmin[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(axis == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">qsort</span>(times+imin, inum, <span class="built_in">sizeof</span>(BVItem), copmpareItemX);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(axis == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">qsort</span>(times+imin, inum, <span class="built_in">sizeof</span>(BVItem), copmpareItemY);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">qsort</span>(times+imin, inum, <span class="built_in">sizeof</span>(BVItem), copmpareItemZ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> isplit = imin + inum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">subdivide</span>(items, nitems, imin, isplit, curNode, nodes);</span><br><span class="line">        <span class="built_in">subdivide</span>(items, nitems, isplit, imax, curNode,nodes);</span><br><span class="line">        <span class="type">int</span> iescape = curNode - icur;</span><br><span class="line">        </span><br><span class="line">        node.i = -iescape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="A星算法确定路径的凸多边形序列"><a href="#A星算法确定路径的凸多边形序列" class="headerlink" title="A星算法确定路径的凸多边形序列"></a>A星算法确定路径的凸多边形序列</h5><p>​		A星算法的流程在前面介绍过，在这只介绍区别。</p>
<p>多边形的F值热河确定：</p>
<p>​		多边形的G值 &#x3D; parent凸多边形的G值 + 代表parent凸多边形的顶点到parent与该多边形公共边中点的欧几里得距离。这里选择顶点代表凸多边形的规则为:parent凸多边形与其本身公共边的中点。</p>
<p>​		多边形的H值 &#x3D; parent与该多边形公共边中点到终点的欧几里得距离。</p>
<p>​		算法迭代过程中，顶点所用的数据结构如下所示，cost代表起点到此所用的开销，total表示F值，pidx代表parent凸多边形，flags代表该点当前是在openList还是closeList中，id代表其所属的凸多边形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dtNode</span>&#123;</span><br><span class="line">    <span class="type">float</span> pos[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> cost;</span><br><span class="line">    <span class="type">float</span> total;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pidx : DT_NODE_PARENT_BITS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> state : DT_NODE_STATE_BITS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags : <span class="number">3</span>;</span><br><span class="line">    ddtPolyRef id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="漏斗算法平滑路径"><a href="#漏斗算法平滑路径" class="headerlink" title="漏斗算法平滑路径"></a>漏斗算法平滑路径</h5><p>整个算法过程可以用下面这个图来描述</p>
<p><img src="/img/friend_404.gif" data-original="/../images/AI/28.png"></p>
<p>​		起点A不仅作为漏斗的初始顶点，也作为漏斗的初始两个端口，此后两个端口不停地向公共边的两个端点移动。</p>
<p>漏斗左右端点继续移动，需要满足下面2个条件</p>
<p>1.移动端点后的边是朝向漏斗收缩的方向。</p>
<p>2.移动端点后的边没有跨过另外1条边。</p>
<p>​		如果移动端点后的边是朝向漏斗收缩的方向，但会跨过另外1条边。— 此时将另外1个端点加入路径，并将其更新为新漏斗的顶点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://jia19791126.github.io">sky小天</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://jia19791126.github.io/posts/15378.html">https://jia19791126.github.io/posts/15378.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jia19791126.github.io" target="_blank">Sky小天的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/algorithms/">algorithms</a><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/Pathfinding-Algorithm/">Pathfinding Algorithm</a></div><div class="post_share"><div class="social-share" data-image="/img/ava.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/64091.html" title="Unity Shader概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity Shader概述</div></div></a></div><div class="next-post pull-right"><a href="/posts/25958.html" title="unity场景加载"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">unity场景加载</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/25958.html" title="unity场景加载"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-27</div><div class="title">unity场景加载</div></div></a></div><div><a href="/posts/64091.html" title="Unity Shader概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="title">Unity Shader概述</div></div></a></div><div><a href="/posts/6443.html" title="Unity Shader语法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="title">Unity Shader语法</div></div></a></div><div><a href="/posts/28891.html" title="Unity Shader入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Unity Shader入门</div></div></a></div><div><a href="/posts/49586.html" title="Unity Shader-光照"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Unity Shader-光照</div></div></a></div><div><a href="/posts/1443.html" title="Unity Shader-法线贴图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="title">Unity Shader-法线贴图</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/friend_404.gif" data-original="/img/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">sky小天</div><div class="author-info__description">Never give up</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jia19791126"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">寻路算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">A*寻路算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">详细原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E8%B7%AF%E6%B6%88%E8%80%97%E5%85%AC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">寻路消耗公式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%88%97%E8%A1%A8%E3%80%81%E5%85%B3%E9%97%AD%E5%88%97%E8%A1%A8%E5%8F%8A%E6%A0%BC%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%88%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">开启列表、关闭列表及格子对象的父对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%B7%AF%E5%BE%84%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">最终路径的确定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%AD%BB%E8%B7%AF"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">判断死路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">算法优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%9C%E7%A2%8D%E9%82%BB%E7%82%B9%E7%9A%84%E9%A2%84%E8%AE%A1%E7%AE%97%E3%80%82"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">障碍邻点的预计算。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">Array数组优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E6%A0%87%E8%AE%B0%EF%BC%8C%E6%8D%A2%E6%8E%89%E4%B8%8D%E7%94%A8%E9%87%8D%E7%BD%AE"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">打开关闭标记，换掉不用重置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91while%E9%87%8C%E9%9D%A2get-set-function"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">减少while里面get&#x2F;set&#x2F;function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%86%8D%E6%8F%90%E4%B8%80%E6%8F%90%E5%BE%AE%E5%B0%8F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">位运算，再提一提微小的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">使用二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E5%A0%86%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.4.6.1.</span> <span class="toc-text">向堆中添加元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E9%98%9F%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.4.6.2.</span> <span class="toc-text">从队中删除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%BC%80%E5%90%AF%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0%E9%87%8D%E6%8E%92"><span class="toc-number">1.1.4.6.3.</span> <span class="toc-text">对开启列表的元素重排</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NavMesh%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">NavMesh导航系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Meadow-mapping"><span class="toc-number">1.2.1.</span> <span class="toc-text">Meadow mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">整体需要实现的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">如何划分凸多边形区域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">如何判断是否为凸多边形</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%BF%94%E5%9B%9E%E7%9A%84%E9%A1%B6%E7%82%B9%E4%B8%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%AD%E5%85%B6%E5%AE%83%E2%80%9C%E5%8F%AF%E8%A7%81%E2%80%9D%E7%9A%84%E9%A1%B6%E7%82%B9%E7%9B%B8%E8%BF%9E"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">将返回的顶点与多边形中其它“可见”的顶点相连</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%92%8C%E9%9D%9E%E4%B8%B4%E8%BE%B9%E7%9B%B8%E4%BA%A4"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">检测不和非临边相交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%BA%BF%E6%AE%B5%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">检测线段是否在多边形内部</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%B4%9E"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">合并洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E7%B4%A0%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">体素化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%93%E7%B4%A0%E5%8C%96"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">为什么要体素化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E7%B4%A0%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">体素化的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%93%E7%B4%A0%E5%8C%96%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">体素化的表达</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recast-Navigation"><span class="toc-number">1.2.3.</span> <span class="toc-text">Recast Navigation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#recast"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">recast</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#recast%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">recast的输入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%8F%AF%E8%A1%8C%E8%B5%B0%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">标记可行走的三角形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%AB%98%E5%BA%A6%E5%9C%BAHeightField"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">构建高度场HeightField</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E5%9C%BA%E7%9A%84%E5%8F%AF%E8%A1%8C%E8%B5%B0%E6%A0%87%E8%AE%B0%E4%BF%AE%E6%AD%A3"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">高度场的可行走标记修正</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%B4%A7%E5%87%91%E9%AB%98%E5%BA%A6%E5%9C%BACompactHeightfield-%E5%8F%8D%E4%BD%93%E7%B4%A0%E5%8C%96"><span class="toc-number">1.2.3.1.5.</span> <span class="toc-text">构建紧凑高度场CompactHeightfield(反体素化)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E5%8F%AF%E8%A1%8C%E8%B5%B0%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.3.1.6.</span> <span class="toc-text">裁剪可行走区域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E4%BD%93%E7%B4%A0%E6%8E%A9%E7%A0%81%E5%80%BC"><span class="toc-number">1.2.3.1.7.</span> <span class="toc-text">标记体素掩码值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.1.8.</span> <span class="toc-text">区域划分算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E8%A3%81%E5%89%AA"><span class="toc-number">1.2.3.1.9.</span> <span class="toc-text">区域裁剪</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%BD%AE%E5%BB%93%E7%BA%BF"><span class="toc-number">1.2.3.1.10.</span> <span class="toc-text">生成轮廓线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.2.3.1.11.</span> <span class="toc-text">凸多边形的合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detour%E5%AF%BB%E8%B7%AF"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">detour寻路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">如何寻找最近的凸多边形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#A%E6%98%9F%E7%AE%97%E6%B3%95%E7%A1%AE%E5%AE%9A%E8%B7%AF%E5%BE%84%E7%9A%84%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">A星算法确定路径的凸多边形序列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%8F%E6%96%97%E7%AE%97%E6%B3%95%E5%B9%B3%E6%BB%91%E8%B7%AF%E5%BE%84"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">漏斗算法平滑路径</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/16906.html" title="Unity Shader-透明效果">Unity Shader-透明效果</a><time datetime="2024-11-14T09:51:56.446Z" title="发表于 2024-11-14 17:51:56">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/44646.html" title="Unity Shader-纹理">Unity Shader-纹理</a><time datetime="2024-11-14T08:54:01.370Z" title="发表于 2024-11-14 16:54:01">2024-11-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1443.html" title="Unity Shader-法线贴图">Unity Shader-法线贴图</a><time datetime="2024-11-12T01:13:45.870Z" title="发表于 2024-11-12 09:13:45">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/49586.html" title="Unity Shader-光照">Unity Shader-光照</a><time datetime="2024-11-05T09:25:20.346Z" title="发表于 2024-11-05 17:25:20">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/28891.html" title="Unity Shader入门">Unity Shader入门</a><time datetime="2024-11-05T03:16:49.011Z" title="发表于 2024-11-05 11:16:49">2024-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By sky小天</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>